generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * NOTE:
 * - We keep model names in PascalCase for readability.
 * - @@map ensures underlying DB tables are snake_case (questions, options, etc.)
 * - Add migrations incrementally.
 */

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  name      String?
  createdAt DateTime   @default(now())
  role      UserRole   @default(STUDENT)
  password  String
  exams     UserExam[]
  answers   Answer[]

  isAnonymized Boolean? @default(false)
  deletedAt DateTime?  

  @@map("users")
}

model Exam {
  id        String     @id @default(uuid())
  name      String
  syllabus  Json?
  createdAt DateTime   @default(now())
  subjects  Subject[]
  users     UserExam[]

  @@map("exams")
}

model UserExam {
  id            String        @id @default(uuid()) 
  userId        String    
  examId        String    
  progress      Json?         @default("{}")
  createdAt     DateTime      @default(now())
  startedAt     DateTime      @default(now())
  finishedAt    DateTime?
  score         Decimal?      @db.Decimal(7,3)
  attemptNumber Int           @default(1)
  status        ExamStatus    @default(IN_PROGRESS)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  exam Exam @relation(fields: [examId], references: [id])

  @@map("user_exams")
  @@unique([userId, examId, attemptNumber])
  @@index([userId])
  @@index([examId])
  @@index([userId, examId, status])
}

enum ExamStatus {
  IN_PROGRESS
  COMPLETED
  ABORTED
} 

model Subject {
  id     String  @id @default(uuid())
  name   String
  examId String
  exam   Exam    @relation(fields: [examId], references: [id])
  topics Topic[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("subjects")
}

model Topic {
  id        String     @id @default(uuid())
  name      String
  subjectId String
  subject   Subject    @relation(fields: [subjectId], references: [id])
  questions Question[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("topics")
}

model Question {
  id        String   @id @default(uuid())
  text      String
  topicId   String
  topic     Topic    @relation(fields: [topicId], references: [id])
  options   Option[]
  createdAt DateTime @default(now())

  questionVersions QuestionVersion[] // back-relation for QuestionVersion.question
  questionTags     QuestionTag[] // back-relation for QuestionTag.question

  @@map("questions")
}

model Option {
  id         String   @id @default(uuid())
  text       String
  isCorrect  Boolean  @default(false)
  questionId String
  question   Question @relation(fields: [questionId], references: [id])

  @@map("options")
}

model Answer {
  id                String           @id @default(uuid())
  userId            String
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionVersionId String?          // nullable if we allow answers without a snapshot
  questionVersion   QuestionVersion? @relation(fields: [questionVersionId], references: [id], onDelete: Cascade)
  selectedOptionId  String?          // snapshot: { id, text }
  isCorrect         Boolean?
  timeTakenMs       Int?
  createdAt         DateTime         @default(now())

  @@index([userId])
  @@index([questionVersionId])
  @@map("answers")
}

/**
 * NEW model: QuestionVersion
 * - snapshots question text and options (as Json)
 * - unique per (questionId, versionNumber)
 */

model QuestionVersion {
  id            String   @id @default(uuid())
  questionId    String
  question      Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  versionNumber Int
  text          String // snapshot of question text (keeps naming consistent with Question.text)
  options       Json // array of options snapshot: [{id, text, isCorrect?}]
  explanation   String?
  metadata      Json?
  createdAt     DateTime @default(now())
  Answer        Answer[]

  @@unique([questionId, versionNumber])
  @@map("question_versions")
}

model Tag {
  id           String        @id @default(uuid())
  name         String        @unique
  createdAt    DateTime      @default(now())
  questionTags QuestionTag[]

  @@map("tags")
}

model QuestionTag {
  questionId String
  tagId      String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([questionId, tagId])
  @@map("question_tag")
}

enum UserRole {
  ADMIN
  STUDENT
}
