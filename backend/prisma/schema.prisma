generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * NOTE:
 * - We keep model names in PascalCase for readability.
 * - @@map ensures underlying DB tables are snake_case (questions, options, etc.)
 * - Add migrations incrementally.
 */

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  name      String?
  createdAt DateTime   @default(now())
  role      UserRole   @default(STUDENT)
  password  String
  exams     UserExam[]
  answers   Answer[]

  isAnonymized Boolean?      @default(false)
  deletedAt    DateTime?
  ExamAttempt  ExamAttempt[]
  WeakArea     WeakArea[]

  @@map("users")
}

model Exam {
  id          String        @id @default(uuid())
  name        String
  syllabus    Json?
  createdAt   DateTime      @default(now())
  subjects    Subject[]
  users       UserExam[]
  ExamAttempt ExamAttempt[]
  WeakArea    WeakArea[]

  @@map("exams")
}

model UserExam {
  id            String     @id @default(uuid())
  userId        String
  examId        String
  progress      Json?      @default("{}")
  createdAt     DateTime   @default(now())
  startedAt     DateTime   @default(now())
  finishedAt    DateTime?
  score         Decimal?   @db.Decimal(7, 3)
  attemptNumber Int        @default(1)
  status        ExamStatus @default(IN_PROGRESS)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  exam Exam @relation(fields: [examId], references: [id])

  @@unique([userId, examId, attemptNumber])
  @@index([userId])
  @@index([examId])
  @@index([userId, examId, status])
  @@map("user_exams")
}

enum ExamStatus {
  IN_PROGRESS
  COMPLETED
  ABORTED
}

model Subject {
  id     String  @id @default(uuid())
  name   String
  examId String
  exam   Exam    @relation(fields: [examId], references: [id])
  topics Topic[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("subjects")
}

model Topic {
  id        String     @id @default(uuid())
  name      String
  subjectId String
  subject   Subject    @relation(fields: [subjectId], references: [id])
  questions Question[]

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  WeakArea  WeakArea[]

  @@map("topics")
}

model Question {
  id        String   @id @default(uuid())
  text      String
  topicId   String
  topic     Topic    @relation(fields: [topicId], references: [id])
  options   Option[]
  createdAt DateTime @default(now())

  questionVersions QuestionVersion[] // back-relation for QuestionVersion.question
  questionTags     QuestionTag[] // back-relation for QuestionTag.question

  @@map("questions")
}

model Option {
  id         String   @id @default(uuid())
  text       String
  isCorrect  Boolean  @default(false)
  questionId String
  question   Question @relation(fields: [questionId], references: [id])

  @@map("options")
}

model Answer {
  id                String           @id @default(uuid())
  userId            String
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  attemptId         String? // NEW: link to ExamAttempt (optional for legacy)
  attempt           ExamAttempt?     @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  questionVersionId String?
  questionVersion   QuestionVersion? @relation(fields: [questionVersionId], references: [id], onDelete: Cascade)
  selectedOptionId  String?
  selectedSnapshot  Json? // NEW: { selectedText, correctOptionText, correctOptionId, ... }
  isCorrect         Boolean?
  timeTakenMs       Int?
  createdAt         DateTime         @default(now())

  @@index([userId])
  @@index([questionVersionId])
  @@index([attemptId]) // NEW
  @@map("answers")
}

/**
 * NEW model: QuestionVersion
 * - snapshots question text and options (as Json)
 * - unique per (questionId, versionNumber)
 */

model QuestionVersion {
  id            String   @id @default(uuid())
  questionId    String
  question      Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  versionNumber Int
  text          String // snapshot of question text (keeps naming consistent with Question.text)
  options       Json // array of options snapshot: [{id, text, isCorrect?}]
  explanation   String?
  metadata      Json?
  createdAt     DateTime @default(now())
  Answer        Answer[]

  @@unique([questionId, versionNumber])
  @@map("question_versions")
}

model Tag {
  id           String        @id @default(uuid())
  name         String        @unique
  createdAt    DateTime      @default(now())
  questionTags QuestionTag[]

  @@map("tags")
}

model QuestionTag {
  questionId String
  tagId      String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([questionId, tagId])
  @@map("question_tag")
}

enum UserRole {
  ADMIN
  STUDENT
}

model ExamAttempt {
  id          String    @id @default(uuid())
  userId      String
  examId      String
  rawSnapshot Json
  score       Decimal?  @db.Decimal(7, 3)
  durationSec Int?
  startedAt   DateTime  @default(now())
  submittedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  exam    Exam     @relation(fields: [examId], references: [id], onDelete: Cascade)
  answers Answer[]

  @@index([userId])
  @@index([examId])
  @@index([submittedAt])
  @@map("exam_attempts")
}

model WeakArea {
  id          String   @id @default(uuid())
  userId      String
  examId      String
  topicId     String
  weight      Float    @default(0.0) // 0..1 where higher => weaker
  meta        Json?
  lastUpdated DateTime @default(now()) @updatedAt
  createdAt   DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  exam  Exam  @relation(fields: [examId], references: [id], onDelete: Cascade)
  topic Topic @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@unique([userId, examId, topicId])
  @@index([userId])
  @@index([examId])
  @@index([topicId])
  @@map("weak_areas")
}
